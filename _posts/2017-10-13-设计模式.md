---
layout:     post                    # 使用的布局（不需要改）
title:      My First Post               # 标题 
subtitle:   Hello World             #副标题
date:       2017-10-10              # 时间
author:     HuXinyu                      # 作者
header-img: img/life-bg-hello.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 生活
---
##策略模式
> 定义了算法族，分别封装起来，让它们之间互相替换，此模式让算法的变化独立于使用算法的客户。

把那些经常需要变化的行为单独拎出来进行封装，通过多个实现类实现该接口完成多态，在产品类中使用封装好的接口对象代理实现产品的某个具体行为。

> 设计原则<br>
> 多用组合，少用继承.

##观察者模式
> 定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。

其一：主题subject（拥有数据的一方）为接口，有某个类实现其接口，该类具有有些数据域及一个集合用于记录观察者。具体的观察者都具有update（...）即实现观察者接口Observer的类，当主题具体的实现类状态改变时，通过循环集合的每个观察者对象并调用每个观察者的update（...）实现通知操作，当然实现观察者接口的类必须在主题实现类中进行注册。这样设计，当主题扩展功能，修改就很麻烦。

其二：java内置的观察者模式。主题Observable是一个类而不是接口，有子类去继承主题类。相对于前面的其更多的是想让观察者主动获取自己本身需要的数据，即“拉”，前面的为“推”。当然这个模式这两种操作都是可以实现的。当继承主题类的子类状态改变时，多了一个状态改变的标志。在构造观察者时多了一个主题类的实例域，当主题类的状态改变时，通过调用自身的update既可以更新数据。但这样设计限制了Observable的复用。

> 设计原则<br>
> 为了交互对象之间的松耦合设计而努力。


##装饰模式
> 动态的将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。

被装饰者（具体组件）继承一个抽象组件，具体装饰类继承抽象装饰者，抽象的装饰者继承抽象组件，具体装饰类中用一个实例变量即被装饰者类来包装被装饰者对象，在构造装饰类时传入被装饰类的对象，完成“装饰”，一个被装饰的对象可以多个装饰类进行“装饰”。装饰类拥有其它的方法来扩展被装饰的类。当一个对象的行为不足以实现时可以使用装饰类扩展其功能。

> 设计原则
> 类应该对扩展开放，对修改关闭

##单件模式
> 确保一个类只有一个实例，并提供一个全局访问点。

用一个静态变量来记录一个类的唯一实例，同时设置该类的构造器为私有方法，通过一个公开的getInstance先判断静态变量是否为null，是则调用私有的构造器创建实例并返回，否则直接返回实例对象。
对于多线程的处理：<br>
1. 声明getInstance方法为线程同步方法即使用synchronized关键字。当你的程序可以接受性能负担时可以使用，毕竟简单。<br>
2. 当使用静态变量时直接创建该类的实例，适用于你的程序频繁创建和使用该实例对象或者你的程序在创建和运行时负担不太繁重可以使用此方法。<br>
3. “双重检查加锁“ 用volatile关键字声明静态变量，用于保证多个线程能够正确处理该变量。在getInstance方法使用线程同步块，之前先判断变量是否为null，是进入同步代码块在进行一次判断，是则创建该实例并赋给静态变量，否则直接返回静态变量。这样保证了同步块只执行一次。适用于你很注重性能需求。

##命令模式
> 将“请求”封装成对象，以便使用不同的请求、队列或日志来参数化其他对象。命令模式也支持可撤销的操作。

定义一个接口，这个接口定义了一个或多个简单的命令或者说动作（方法）。由某个具体的命令/动作的实现类来完成具体的“命令/动作”。在这些实现类中都存在各自的某个产品对象的实例域，毕竟只有产品对象本身才能实现“命令/动作”。<br>
当使用一个对象使用不同组命令/动作时，可在该类中定义一个或多个命令/动作的数组/集合。在构造器中实例化并初始化这些数组/集合。这样就可以使用产品类实例化某个命令/动作的实现类，把这些命令的实现类set进某个单一对象或者说是控制器中，然后我们就可以使用这个控制器对象执行不同产品对象的相同或者不同的“命令/动作”，达到一种一个对象多种命令，一个命令多种产品的效果。