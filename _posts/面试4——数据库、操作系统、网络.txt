
# 一、数据库
## 1、表的建立、删除、修改
* **建表：**没什么可说的
* **删除：**注意restrict和cascade
* **修改：**包括增加列、删除列、修改列的类型

## 2、查询
* **单表查询：**只涉及一个表。5、12、20、30、31、32、
* **连接查询：**涉及多个表。37、38
* **嵌套查询：**将一个查询快嵌套在where或having子句中，主要使用的连接词：in、比较运算符、any/all（必须配合比较运算符）、exists
* **集合查询：**对多个select结果再进行操作，包括：union（交）、intersect（交）、except（差）

## 3、范式
* **第一范式：**表中的每一个属性都不可再分。
* **第二范式：**在第一范式基础上，每一个非主属性完全依赖于码。
* **第三范式：**在第二范式基础上，每一个非主属性不存在对于码的传递函数依赖和部分依赖。
* **BC范式：**在第三范式基础上，消除主属性对于码的部分与传递函数依赖。

记忆：

第一范式很简单，没什么可说的。

第二范式和第三范式都是说的**非主属性与码的关系。**

BC范式说的是**主属性与码的关系。**

## 4、索引的作用
索引是一个数据库对象，使用索引，可以使数据库程序无须对整个数据进行扫描，就可以在其中找到目标数据，从而提高查找效率。索引的底层采用的是B树。

# 二、操作系统
## 1、进程和线程
### 1）进程和线程的区别

**进程**是拥有资源，且独立调度和运行的基本单位。进程是程序运行时的实例，每个进程都有各自独立的地址空间，一个进程不能访问另一个进程的内存。

** 线程**是可以独立调度和运行的基本单位，但它只拥有极少数的内存资源。

线程存在于进程中，同一个进程中的多个线程可以共享进程中的堆空间，但是每个线程都有各自的寄存器和栈。
### 2）进程的状态转换
就绪、运行、阻塞

### 3）进程的互斥和同步
**互斥：**是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。 

**同步：**是指在互斥的基础上，实现访问者对资源的**有序访问**。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。

**简单地说：同步体现的是一种协作性，互斥体现的是一种排他性。**

### 4）进程间的通信方式
**1、管道**
管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。

**2、信号量**
信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它**常作为一种锁机制**，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，**主要作为进程间以及同一进程内不同线程之间的同步手段。**

**3、共享内存**
共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。**共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。**

**4、套接字( socket )**
套接字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同终端及其间的进程通信。

**5、消息队列**


## 2、处理机调度算法
**1、先来先服务**

该进程一直运行到完成或发生某件事而阻塞后，才放弃处理机。

对长作业有利，段作业无力。

**2、短作业优先**

该算法是从就绪队列中选**一个或若干**运行时间最短的，将处理机分配给它。

这里又分抢占式和非抢占式。

**3、高优先权优先调度**

系统从后备队列中选择**一个或若干**个优先权最高的作业装入内存。

分为抢占式和非抢占式。

**4、高响应比优先**

优先权=（等待时间+要求服务时间）/要求服务时间

**5、时间片轮转**

重点是时间片的选择，较为可取的大小是：时间片略大于一次典型的交互所需要的时间。

**6、多级反馈队列**

第一个队列优先级最高，时间片最小。任务在第一个队列没执行完，就把它下方。

仅当第1――i-1个队列为空，才会调度第i个队列的内容。

## 3、死锁
### 1）产生死锁的原因
1、竞争资源

2、进程间推进顺序不当
就是请求和释放资源的顺序不当。

### 2）产生死锁的四个必要条件（必须、同时）
1、互斥条件

2、请求和保持条件

3、不剥夺条件

4、环路等待条件

### 3）预防死锁
既然是必要条件，那么预防死锁的方法，就是**破坏四个必要条件之一。**

### 4）死锁的避免
银行家算法。

## 4、磁盘调度算法
**1、先来先服务**

**2、最短寻道时间**

**3、扫描算法**

考虑磁头移动的方向，先向一个方向寻道。

每次访问同一个方向，且距离最近的。

**4、循环扫描**
磁头单向移动，只从里向外，或从外向里。

**5、NStepScan**

避免“磁臂黏着现象”。

也是建立多个队列，队列之间使用先来先服务算法，队列内使用scan算法，有新的请求就放入其它队列。

## 5、内存分配方式
**1、连续分配**

* 单一连续分配
* 固定分区分配
* 动态分区分配
* 可重定位分区分配：需要硬件的支持

**2、基本分页存储管理**
分页存储管理是将一个进程的地址（逻辑地址空间）空间划分成若干个大小相等的区域，称为页，相应地，将内存空间划分成与页相同大小（为了保证页内偏移一致）的若干个物理块，称为块或页框（页架）。在为进程分配内存时，将进程中的若干页分别装入多个不相邻接的块中。 

**3、请求分页**

**4、基本分段存储管理**

引入的目的是为了满肚程序员在编程和使用上多方面的要求，且消除了内碎片。

在分段存储管理方式中，作业的地址空间被划分为若干个段，每个段是一组完整的逻辑信息，如有主程序段、子程序段、数据段及堆栈段等，每个段都有自己的名字，都是从零开始编址的一段连续的地址空间，各段长度是不等的。

**5、分页与分段的区别**

 1.页是信息的物理单位，分页是为了实现非连续的分配，以便解决内存的碎片问题，或者说分页是为了系统管理的需要。

2.页的大小固定是由系统确定的，将逻辑地址划分为页号和页内地址是由机器硬件实现的。而段的长度是不固定的，决定与用户的程序长度，通常由编译程序进行编译时根据信息的性质来划分。 

3.分页式存储管理的作业地址空间是一维的，分段式的存储管理的作业管理地址空间是二维的。

**6、页面置换算法**

1、最佳置换算法
选择那些永不使用的，或者是在最长时间内不再被访问的页面置换出去。（它是一种理想化的算法，性能最好，但在实际上难于实现）。 

2、先进先出置换算法
该算法总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予以淘汰。 

3、最近最久未使用置换算法
该算法是选择最近最久未使用的页面予以淘汰，系统在每个页面设置一个访问字段，用以记录这个页面自上次被访问以来所经历的时间T，当要淘汰一个页面时，选择T最大的页面。

4、最少使用置换算法：
该算法选择最近时期使用最少的页面作为淘汰页。

5、Clock置换算法
该算法为每个页面设置一位访问位，将内存中的所有页面都通过链接指针链成一个循环队列。当某页被访问时，其访问位置“1”。在选择一页淘汰时，就检查其访问位，如果是“0”，就选择该页换出；若为“1”，则重新置为“0”，暂不换出该页，在循环队列中检查下一个页面，直到访问位为“0”的页面为止。由于该算法只有一位访问位，只能用它表示该页是否已经使用过，而置换时是将未使用过的页面换出去，所以把该算法称为最近未用算法。 

## 6、Linux

## linux常用命令
我的笔记本。


# 三、网络
## 1、五层模型

## 2、TCP/IP
* **三次握手/四次挥手**
* **SYN与FIN**

**为什么连接的时候是三次握手，关闭的时候却是四次握手？**

 因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Clien端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步撒手。

## 3、Http及其完整的请求过程
### 请求过程
看我博客：https://thinkchao.github.io/2017/07/15/coder-2/
### 请求方法
* **GET：**GET用于信息获取，请求参数都要放到请求的URL中。
* **POST：**POST用来修改服务器资源的请求
* **PUT：**与GET相反，PUT用来向服务器写入资源
* **DELETE：**让服务器删除请求URL所指定的资源
* **HEAD：**与GET类似，但服务器在响应中只返回首部。使用head可以在不获取资源的情况下了解资源的情况。
* **TRACE：**trace方法主要用于诊断，用于验证请求是否如愿穿过了请求/响应链。它允许客户端在最终将请求发送给服务器时 ，看Http请求变成了什么样子。因为一个Http请求可能要穿过防火墙、代理、网关或其它一些应用程序。
* **OPTION：**该方法请求web服务器告知其支持的各种功能，例如支持哪些方法，或者对某些特殊资源支持哪些方法。

### 常见请求头部
* **ContentType：**请求数据的格式
* **Content-Length：**消息长度
* **Host：**请求的主机名
* **User-Agent：**发出请求的浏览器类型
* **Accept：**客户端可识别的内容类型列表
* **Accept-Encoding：**客户端可识别的数据编码
* **Connection：**

### Http1.0与Http1.1区别
1、Http1.1的缓存控制策略更多

2、带宽优化

3、host头的处理

4、Http1.1支持长连接，也就是可以在一个TCP链接上，可以传送多个Http请求和链接，较少了建立和关闭链接的消耗。

### Http与https
Https就是在Http层和TCP层加入了一层TLS加密层。

SSL协议是一种安全传输协议，TLS是SSL 3.0的升级版。

 HTTP和HTTPS使用的是完全不同的连接方式用的**端口也不一样**：前者是80，后者是443。

